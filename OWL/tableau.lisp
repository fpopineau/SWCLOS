;;;-*- Mode: common-lisp; syntax: common-lisp; base: 10 -*-
;;;
;;;; Tableau Algorithm for OWL DL
;;;
;;; Copyright (c) Seiji Koide 2009
;;;
;; History
;; -------
;; 2007.10.13    File created

(cl:defpackage :gx
  (:export )
  )

(eval-when (:execute :load-toplevel :compile-toplevel)
  ) ; end of eval-when

(in-package :gx)

(defun what-if-tableau (dr R maxc minc)
  (error "Not Yet!"))

;;;
;;; DL is one variable fragment of FOL formula, in which a variable is tacitly
;;; universaly quantified. Therefore, in the sense of FOL, DL does not need to express the
;;; variable, because one variable outside of formula can be ignored in syntax. However,
;;; an ABox in Tableau may include a number of individuals that are generated by existential
;;; restriction, and these individuals C(x) and C(y) must be distinguished. Precisely,
;;; if C(?) is generated and added into ABox from an existential restriction in tableau,
;;; then the variable '?' must be discreminated from other variables x or y and constants
;;; a or b in ABox, and must be preserved as is. As a result, we need to distinguish variables
;;; x and y and distinguish individual C(x) and C(y).
;;;
;;; In SWCLOS, an individual C(x) is bound to its QName symbol x. Therefore, we implement the
;;; binding mechanism in ABox as assoc list. You might recall assoc lists are an innate binding
;;; mechanism in old lisp. This ABox bindings here are integrated to the SWCLOS environment.
;;; Namely, every function must work in a common variable space of ABox and SWCLOS, and we
;;; intend to have variable values rebound freely in ABox apart from SWCLOS. To do so, an
;;; individual C(x) may be implemented in ABox for class bindings as binding (x . C),
;;; where C is a class object or name or complex representation of class. In a similar way,
;;; an extention of property R(x,y) is implemented in ABox for relation bindings as binding
;;; (x . R(.y)),  where R(.y) is an anonymous individual object that holds filler y for role
;;; R or a list form '(R y). Thus, we can retrieve class values and relations for x by the
;;; mechanism that resembles SWCLOS only by taking care of variable binding and value getting.
;;;
;;; Please note that these two binding abox, class-binding and relation binding are
;;; discreminated to unification bindings in unification process.
;;;

(defstruct abox class relation)
(defun class-binding-of (x abox)
  (assoc x (abox-class abox)))
(defun relation-binding-of (x abox)
  (assoc x (abox-relation abox)))
(defun get-relation-of (rel alist)
  (assoc rel alist))
(defun get-relation-of-binding (x rel abox)
  (assoc rel (assoc x (abox-relation abox))))

(defun collect-all-class-values (x abox)
  (loop for binding in abox
      when (eq x (car binding))
      collect (cdr binding)))

(defun collect-all-relation-values (x rel abox)
  (loop for binding in abox
      when (eq x (car binding))
      append (loop for bind in (cdr binding)
                 when (eq rel (car bind))
                 collect (cdr bind))))

(defun tbox-clash-p (label)
  (and (cdr label) ; length >= 2
       (loop for classes on label with C
           do (setq C (car classes))
             (loop for D in (cdr classes)
                 when (tbox-disjoint-p C D)
                 do (return-from tbox-clash-p t)))))

;;
;; Satisfiability on ABox
;; In the followings, clash means unsatisfiable in DL, when ABox is inconsistent.
;;
;; (var . C(.)) and (var . (Not C(.)))   -> clash     ; this comes from original Tableau.
;; (var . R(.f)) and (var . (Not R(.f))) -> clash
;; C and (disjoint C) for identical var  -> clash     ; this comes from SWCLOS functions.
;;

(defun clash-p (abox)
  "Is abox inconsitent, e.g., both P and (Not P) exist or C for C(x) and D for D(x) are
   disjoint. abox must be complete, i.e., there is no more transformation.
   This function returns a set of inconsistent concepts."
  (loop for alst on (abox-class abox)
      do (let ((c-var (binding-var (car alst)))
               (c-cls (binding-val (car alst))))
           (loop for d-cls in (collect-all-class-values c-var abox)
               when (tbox-disjoint-p c-cls d-cls)
               do (return-from clash-p (cl:list c-cls d-cls))))))

(defun tbox-disjoint-p (c d)
  ; resolve symbol and object
  ; c and d are concepts.
  (cond ((null c) cl:nil)
        ((null d) cl:nil)
        ((equal c d) cl:nil)      ; c/d may be lisp forms.
        ((and (eq c |owl|:|Thing|) (eq d |owl|:|Nothing|)) t)
        ((and (eq c |owl|:|Nothing|) (eq d |owl|:|Thing|)) t)
        ((and (eq c +top+) (eq d +bottom+)) t)
        ((and (eq c +bottom+) (eq d +top+)) t)
        ((and (consp c) (eq (op c) 'Not))
         (owl-equivalent-p (arg1 c) d))    ; because of NNF
        ((and (consp d) (eq (op d) 'Not))
         (owl-equivalent-p c (arg1 d)))    ; because of NNF
        ((and (owl-class-p c) (owl-class-p d))
         (disjoint-p c d))
        ((and (owl-class? c) (owl-class? d))
         (disjoint-p (symbol-value c) (symbol-value d)))
        ((and (symbolp c) (class? c))
         (tbox-disjoint-p (symbol-value c) d))
        ((and (symbolp d) (class? d))
         (tbox-disjoint-p c (symbol-value d)))
        ))

;; Assuming abox is complete and each sentence is NNF
;; this should be memoized soon.
(defun abox-disjoint-p (c-val d-val bindings)
  "c-val = (C) or an individual of C or
         = (R x) or an individual that has role R and filler x.
   d-val = (D) or an indiviudal of D or
         = (R y) or an individual that has role R and filler y."
  (cond ((equal c-val d-val) cl:nil)
        ((and (symbolp c-val) (resource? c-val))
         (abox-disjoint-p (symbol-value c-val) d-val bindings))
        ((and (symbolp d-val) (resource? d-val))
         (abox-disjoint-p c-val (symbol-value d-val) bindings))
        ((and (resource-p c-val) (resource-p d-val))
         (tbox-disjoint-p (class-of c-val) (class-of d-val)))
        ((and (consp c-val) (consp d-val))
         (when (eq (car c-val) 'instance) (setq c-val (cdr c-val)))
         (when (eq (car d-val) 'instance) (setq d-val (cdr d-val)))
         (when (eq (car c-val) 'related) (setq c-val (cl:list (third c-val) (second c-val))))
         (when (eq (car d-val) 'related) (setq d-val (cl:list (third d-val) (second d-val))))
         (cond ((and (null (second c-val)) (null (second d-val))) ; arity = 0 then concepts
                (tbox-disjoint-p (car c-val) (car d-val)))
               ((and (second c-val) (second d-val))               ; arity = 1 then relation
                (cond ((and (property? (car c-val)) (property? (car d-val))
                            (equivalent-property-p (car c-val) (car d-val)))
                       (abox-disjoint-p (second c-val) (second d-val) bindings))))))
        ((and (consp c-val) (resource-p d-val))
         (when (eq (car c-val) 'instance) (setq c-val (cdr c-val)))
         (when (eq (car c-val) 'related) (setq c-val (cl:list (third c-val) (second c-val))))
         (cond ((null (second c-val))                            ; arity = 0
                (tbox-disjoint-p (car c-val) (class-of d-val)))
               ((second c-val)                                   ; arity = 1
                (abox-disjoint-p (slot-filler c-val) (-> d-val (slot-role+ c-val)) bindings))
               ))
        ((and (resource-p c-val) (consp d-val))
         (when (eq (car d-val) 'instance) (setq c-val (cdr d-val)))
         (when (eq (car d-val) 'related) (setq d-val (cl:list (third d-val) (second d-val))))
         (cond ((null (second d-val))                            ; arity = 0
                (tbox-disjoint-p (class-of c-val) (car d-val)))
               ((second d-val)                                   ; arity = 1
                (abox-disjoint-p (-> c-val (slot-role+ d-val)) (slot-filler d-val) bindings))
               ))
        ))
#|
(defun satisfiable-p (P abox)
  "P is a sentence, normally a complex concept.
   If P is null, only abox is used.
   This function returns satisfiable models with P."
  ; Conjunction Normal Form (CNF) is also NNF
  (when P
    (etypecase P
      (|owl|:|Class|
       (setf (abox-class abox)
         (extend-bindings (new-variable "x") (cons (=>cnf P)) (abox-class abox))))
      (|owl|:|Thing|
       (setf (abox-relation abox)
         (extend-bindings (new-variable "x") (cons (=>cnf P)) (abox-relation abox))))
      (symbol
       (cond ((resource? P) (satisfiable-p (symbol-value abox) abox))
             ((variable? P) (error "Not Yet!"))
             (t ;; maybe not defined class symbol
              (setf (abox-relation abox)
                (extend-bindings (new-variable "x") (cons (=>cnf P)) (abox-relation abox))))))
      (cons
       (cond ((connector-p (op P))
              (cond ((eq (op P) 'instance)
                     (setf (abox-class abox)
                       (extend-bindings (new-variable "x") (cons (=>cnf (arg P))) (abox-class abox))))
                    ((eq (op P) 'related)
                     (setf (abox-relation abox)
                       (extend-bindings (new-variable "x") (cons (=>cnf P)) (abox-relation abox))))
                    (t
                     (setf (abox-class abox)
                       (extend-bindings (new-variable "x") (cons (=>cnf P)) (abox-class abox))))))
             ((owl-class? (op P))
              (setf (abox-class abox)
                (extend-bindings (new-variable "x") (cons (=>cnf P)) (abox-class abox))))
             ((property? (op P))
              (setf (abox-relation abox)
                (extend-bindings (new-variable "x") (cons (=>cnf P)) (abox-relation abox))))
             (t (error "Cant happen!"))))))
  (setf (abox-class abox)
    (transform-intersection (abox-class abox)))
  (transform-union (abox-class abox)))
|#
;; x:(Intersect C D) -> (x . (instance C)), (x . (instance D))
(defun transform-intersection (class-abox)
  "returns transformed class-abox."
  (loop for (var . cls) in class-abox
      do (cond ((and (symbolp cls) (boundp cls) (symbol-value cls))
                (setq abox (%transform-intersection var (symbol-value cls) class-abox)))
               ((consp val)
                (cond ((%predicate?+ (op val)) (error "Not Yet! Existential"))
                      ((%concept?+ (op val))
                       (setq abox (%transform-intersection var (op val) abox)))
                      ((error "Cant happen!"))))
               ((error "Cant happen! ~S ~S" var val))))
  abox)

(defun %transform-intersection (var val-class class-abox)
  ;; returns transformed abox
  (etypecase val-class
    (symbol
     (when (and (class? val-class) (intersection-of (symbol-value val-class)))
       (let ((newval `((Intersect ,@(intersection-of (symbol-value val-class))))))
         (unless (isthere var newval abox)
           (return-from %transform-intersection
             (transform-intersection (insert-bindings var newval abox)))))))
    (|rdfs|:|Resource|
     (when (intersection-of val-class)
       (let ((newval `((Intersect ,@(intersection-of val-class)))))
         (unless (isthere var newval abox)
           (return-from %transform-intersection
             (transform-intersection (insert-bindings var newval abox)))))))
    (cons
     (case (op val-class)
       (Intersect
        (loop for C in (args val-class)
            unless (isthere var `(,C) abox)
            do (setq abox (transform-intersection (insert-bindings var `(instance ,C) abox)))))
       ((UnionOf Exists Forall Fills Not <= >= =) )
       (otherwise
        (error "Not Yet!")
        ))))
  abox)


(defun expand-node (node)
  (%expand-node (mklist (tnode-label node)) node))
(defun %expand-node (label node)
  (when (tbox-clash-p label)
    (return-from %expand-node cl:nil))
  (or
   (mapcan #'(lambda (this)
               ;(format t "~%this=~S" this)
               (let ((conjuncts ())
                     (disjuncts ()))
                 (etypecase this
                   (|owl|:|someValuesFromRestriction|
                    (let ((R (name (onproperty-of this)))
                          (C (slot-value this '|owl|:|someValuesFrom|)))
                      (let ((found (find-if #'(lambda (edge) (eq (tedge-label edge) R))
                                            (tnode-edge node))))
                        (when (or (not found)
                                  (not (cl:member C (mklist (tnode-label (tedge-obj found)))
                                                  :test #'subtypep)))
                          (let* ((tonode (make-tnode :label C))
                                 (edge (make-tedge :label R :subj node :obj tonode)))
                            (return-from %expand-node (expand-node node)))))))
                   (|owl|:|allValuesFromRestriction|
                    (let ((R (name (onproperty-of this)))
                          (C (slot-value this '|owl|:|allValuesFrom|)))
                      (let ((found (find-if #'(lambda (edge) (eq (tedge-label edge) R))
                                            (tnode-edge node))))
                        (when (and found
                                   (not (cl:member C (mklist (tnode-label (tedge-obj found)))
                                                   :test #'subtypep)))
                          (setf (tnode-label (tedge-obj found))
                            (push C (mklist (tnode-label (tedge-obj found)))))
                          (return-from %expand-node (expand-node node))))))
                   (|owl|:|hasValueRestriction|
                    (let ((R (name (onproperty-of this)))
                          (a (slot-value this '|owl|:|hasValue|)))
                      (let ((found (find-if #'(lambda (edge) (eq (tedge-label edge) R))
                                            (tnode-edge node))))
                        (when (or (not found)
                                  (not (cl:member a (mklist (tnode-label (tedge-obj found)))
                                                  :test #'typep)))
                          (let* ((tonode (make-tnode :label (cl:list 'OneOf a)))
                                 (edge (make-tedge :label R :subj node :obj tonode)))
                            (return-from %expand-node (expand-node node)))))))
                   (|owl|:|Class|
                    ;; Lazy unfolding - in tableau, a concept is only unfolded
                    ;; when it appears in a node label.
                    (when (and (setq conjuncts (intersection-of this))
                               (set-difference conjuncts label))
                      (setf (tnode-label node) (union label conjuncts))
                      (return-from %expand-node (expand-node node)))
                    (when (and (setq disjuncts (union-of this))
                               (some #'(lambda (d) (not (cl:member d label))) disjuncts))
                      (return-from %expand-node
                        (loop for disj in disjuncts
                            do ;(format t "~%disj=~S" disj)
                            append (cond ((cl:member disj label) (cl:list label))
                                         (t (mappend #'(lambda (lbl)
                                                         (let ((branch (append lbl label)))
                                                           (unless (tbox-clash-p branch)
                                                             (cl:list branch))))
                                              (%expand-node (cl:list disj) node))
                                             )))))
                    ))))
     label)
   (cl:list label)))

#|
(satisfiable-p `(Intersect ,food:ConsumableThing ,food:NonConsumableThing))
(satisfiable-p `(Intersect ,vin:WhiteWine ,vin:RedWine))
(satisfiable-p `(Intersect ,vin:LateHarvest ,vin:EarlyHarvest))
(satisfiable-p `(Intersect ,vin:WineBody ,vin:WineSugar))
(%expand-node (mklist vin:Zinfandel))
(%expand-node (mklist vin:WineDescriptor))
|#

;;
;; We need to discreminate a literal and complex in FOL syntax.
;;

(defvar *operators* '(Intersect UnionOf Exists Forall Fills Not <= >= =))
(defvar *relations* '(implies instance related))

(defun connector-p (x)
  (cond ((cl:member x *operators*) t)
        ((cl:member x *relations*) t)))


;; Normaly, the parameter val is a bound value in an ABox or a binding.
(defun %individual?+ (val)
  (cond ((%instance-p val))
        ((and (symbolp val) (boundp val) (%instance-p (symbol-value val))))
        ((consp val)
         (cond ((eq (op val) 'related))  ; = (related y R)
               ((eq (op val) 'instance)) ; = (instance C)
               ((%predicate?+ (op val))) ; = (R y)
               ((%concept?+ (op val)))   ; = (C)
               ))))

(defun %predicate?+ (R)
  (cond ((property-p R))                                             ; property object
        ((and (symbolp R) (boundp R) (property-p (symbol-value R)))) ; property object
        ))

(defun %concept?+ (C)
  (cond ((rdf-class-p C))                                                 ; class object
        ((symbolp C) (and (boundp C) (rdf-class-p (symbol-value C))))     ; class symbol
        ((consp C)                                                        ; complex
         (case (op C)
           ((Intersect UnionOf Exists Forall Fills Not <= >= =) t) ; complex class
           (otherwise
            (cond ((%metaconcept?+ (op C)))
                  ))))))

(defun %metaconcept?+ (C)
  (cond ((rdf-metaclass-p C))                                             ; metaclass object
        ((symbolp C) (and (boundp C) (rdf-metaclass-p (symbol-value C)))) ; metaclass symbol
        ((consp C)                                                        ; complex
         (case (op C)
           ((Intersect UnionOf Exists Forall Fills Not <= >= =) t) ; complex class
           (otherwise
            (cond ((%metaconcept?+ (op C)))
                  ))))))

#|
(%individual?+ '(instance vin:Zinfandel))
(%individual?+ '(related y R))
(%individual?+ vin:ElyseZinfandel)
(%individual?+ vin:Zinfandel)
(%individual?+ `(,vin:Zinfandel))
(%individual?+ `((Intersect ,vin:Zinfandel ,vin:RedWine)))
(%individual?+ '((Intersect vin:Zinfandel vin:RedWine)))
(%individual?+ '(vin:Zinfandel))
(%individual?+ '((|owl|:|Class|)))
(%individual?+ '(|owl|:|hasValue| ?y))
(%individual?+ `(,|owl|:|hasValue| ?y))
|#

(defun make-constant (class name)
  "makes an instance of <class> with <name> and returns its name."
  (cond ((and (symbolp name) (gx:resource? name)
              (gx:owl-thing-p (symbol-value name)))
         (error "Not Yet"))
        (t (gx:name (gx:addInstance class name)))))

(defun append-bindings- (var val bindings)
  "Add a (var . val) pair at the tail of a binding list."
  (append
   ;; Once we add a binding,
   ;; we can get rid of the dummy +no-bindings+
   (if (eq bindings +no-bindings+)
       cl:nil
     bindings)
   (cl:list (cons var val))))

(defun insert-bindings (var val bindings)
  "Add a (var . val) pair into the position after non-class binding."
  (let* ((binding (assoc var bindings))
         (var-val (cdr binding)))
    (cond ((null binding)
           (acons var val
                  (if (eq bindings +no-bindings+)
                      cl:nil
                    bindings)))
          ((atom var-val)
           (let ((this (cl:member binding bindings :test #'eq)))
             (rplacd this (cons (cons var val) (cdr this)))
             bindings))
          ((consp var-val)
           (cond ((%predicate?+ (op var-val))
                  (let ((this (cl:member binding bindings :test #'eq)))
                    (rplacd this (cons (cons var val) (cdr this)))
                    bindings))
                 ((%concept?+ (op var-val))
                  (let ((this (cl:member binding bindings :test #'eq)))
                    (rplacd this (cons (cons var val) (cdr this)))
                    bindings))))
          ((let ((this (cl:member binding bindings :test #'eq)))
             (rplacd this (cons (cons var val) (cdr this)))
             bindings)))))

;;
;; ABox may include variable pointer chaines or substitutes, generated by unification.
;; bindings = ((z . (C)) (x . y) (y . z) (z . zz)), here x,y,z are symbols
;; (deref x bindings) -> zz
;; (class-of+ x bindings)

(defun deref (x bindings)
  (let ((binding (assoc x bindings)))
    (cond ((null binding) (and (symbolp x) (boundp x) (symbol-value x)))
          ((symbolp (binding-val binding)) (deref (binding-val binding) bindings))
          (t (binding-val binding)))))

;;
;; ABox may includes multiple occurences of bindings for constants and variables.
;; C(a) and D(a) is added to ABox from a sentence (Intersect C D)(a)
;;

(defun collect-all-values (var bindings)
  "get all values for var in bindings."
  (append (%collect-all-values var bindings)             ; from ABox
          (when (and (boundp var) (symbol-value var))    ; from SWCLOS
            (cl:list (symbol-value var)))))

(defun %collect-all-values (var bindings)
  (loop for (x . x-val) in bindings
      when (eq x var)
      append (or (%collect-all-values x-val bindings) (cl:list x-val))))

(defun isthere (var val bindings)
  "Is there a pair of (var . val) in bindings?"
  (some #'(lambda (binding)
            (let ((x-var (binding-var binding))
                  (x-val (binding-val binding)))
              (and (eq var x-var)
                   (cond ((consp x-val)
                          (cond ((eq (car x-val) 'instance)
                                 (owl-equalp val (cdr x-val)))
                                ((eq (car x-val) 'related)
                                 (owl-equalp val (cdr x-val)))
                                (t (owl-equalp val x-val))))
                         (t (owl-equalp val x-val))))))
        bindings))

#|
(collect-all-values '?x '((?y . (vin:Zinfandel)) (?x . ?y) (?x . (vin:Wine)) (?x . (R ?y))
                          (?x . vin:ElyseZinfandel) (a . (vin:RedWine)) (a . (vin:Wine))))
(collect-all-values '?x '((?y . (vin:Zinfandel)) (?x . ?y) (?x . (instance vin:Wine))
                          (?x . (related ?y R))
                          (?x . vin:ElyseZinfandel) (a . (vin:RedWine)) (a . (vin:Wine))))
(collect-all-values 'a '((?y . (vin:Zinfandel)) (?x . ?y) (?x . (vin:Wine))
                         (?x . vin:ElyseZinfandel) (a . (vin:RedWine)) (a . (vin:Wine))))
|#
;;
;; ABoxes: each ABox represents a model that generated parent proposition.
;; If some of ABox in ABoxes is satisfiable, then ABoxes are satisfiable,
;; because, all of them are generated from one parent by disjunction branching.
;;

(defconstant +top+ '+top+)
(defconstant +bottom+ '+bottom+)

(defvar *ABoxes* `(( ))
  "a set of ABox.
   Note that this ABox includes only virtual bindings for variables.
   An ABox is an assoc list that contains (x . (class-symbol)) or (x . C(.)),
   or (x . (property-symbol filler)) or (x . r(.filler)), where C(.) is an anonymous individual
   of class C and r(.filler) represents an anonymous individual that holds role r and the
   filler. This anonymous individuals provide class information and slot information for the
   variable.")

(defun slot-role+ (slot)
  (let ((role (slot-role slot)))
    (case role
     (Intersect '|owl|:|intersectionOf|)
     (UnionOf '|owl|:|unionOf|)
     (Not '|owl|:|complementOf|)
     (otherwise role))))

#|
(collect-all-values '?x '((?x . ?y) (?y . (C)) (?x . (instance (Not C))) (a . (C)) (a . (D))))
(clash-p '((?x . ?y) (?y . (C)) (?x . (instance (Not C))) (a . (C)) (a . (D))))
|#

;;
;; Method Develop develops an complex object to a lisp form in ABox.
;;

(defmethod develop ((class symbol))
  (when (resource? class) (develop (symbol-value class))))

(defmethod develop ((class |owl|:|Class|))
  (let ((forms ())
        (intersections (intersection-of class))
        (unions (union-of class))
        (complement (complement-of class)))
    (when intersection (push `(Intersect ,@intersection) forms))
    (when unions (append forms `((UnionOf ,@unions))))
    (when complement (push `(Not ,complement) forms))
    forms))

(defmethod develop ((restriction |owl|:|someValuesFromRestriction|))
  `(Exists ,(name (slot-value restriction '|owl|:|onProperty|))
           ,(slot-value restriction '|owl|:|someValuesFrom|)))

(defmethod develop ((restriction |owl|:|allValuesFromRestriction|))
  `(Forall ,(name (slot-value restriction '|owl|:|onProperty|))
           ,(slot-value restriction '|owl|:|allValuesFrom|)))

(defmethod develop ((restriction |owl|:|hasValueRestriction|))
  `(Fills ,(name (slot-value restriction '|owl|:|onProperty|))
          ,(slot-value restriction '|owl|:|hasValue|)))

;;
;; Transformation Rules in ABox
;;
(defun %satisfied-p (abox)
  (setq abox
        (loop for bindings on abox
            collect (cond ((slot-value+ (binding-val (car bindings))
                                        '|rdfs|:|subClassOf|
                                        bindings)
                           )
                          (t val))))
  (setq aboxes
        (loop for abox in aboxes
            collect (exists-transform abox)))
  (when (every #'clash-p aboxes) (return-from %satisfied-p cl:nil))
  aboxes)

(defun transform (aboxes)
  (setq aboxes (loop for abox in aboxes collect (intersect-transform abox)))
  (loop for abox in aboxes
      do (setq aboxes
               (union aboxes
                      (union-transform abox aboxes))))
  aboxes)

(defun union-transform (abox aboxes)
  "returns a list of transformed abox."
  (loop for (var . val) in abox
      do (setq aboxes
               (union aboxes
                      (cond ((%instance-p val)
                             (%union-transform var (class-of val) abox aboxes))
                            ((and (symbolp val) (boundp val) (%instance-p (symbol-value val)))
                             (%union-transform var (class-of (symbol-value val)) abox aboxes))
                            ((consp val)
                             (cond ((eq (op val) 'instance)
                                    (%union-transform var (op val) abox aboxes))
                                   ((%predicate?+ (op val)) (error "Not Yet! Existential"))
                                   ((%concept?+ (op val))
                                    (%union-transform var (op val) abox aboxes))
                                   ((error "Cant happen!"))))
                            ((error "Cant happen!"))))))
  aboxes)

(defun %union-transform (var val-class abox aboxes)
  ;; returns aboxes from abox
  (etypecase val-class
    (symbol
     (when (and (resource? val-class) (union-of (symbol-value val-class)))
       (setq val-class `(UnionOf ,@(union-of (symbol-value val-class))))
       (let ((newval `(,val-class)))
         (unless (isthere var newval abox)
           (let ((newabox (append-bindings- var newval abox)))
             (return-from %union-transform
               (%union-transform var val-class newabox (substitute newabox abox aboxes))))))))
    (|rdfs|:|Resource|
     (when (union-of val-class)
       (setq val-class `(UnionOf ,@(union-of val-class)))
       (let ((newval `(,val-class)))
         (unless (isthere var newval abox)
           (let ((newabox (append-bindings- var newval abox)))
             (return-from %union-transform
               (%union-transform var val-class newabox (substitute newabox abox aboxes))))))))
    (cons
     (case (op val-class)
       (UnionOf
        (let ((relatives
               (remove-if-not #'(lambda (abox)
                                  (find-if #'(lambda (binding)
                                               (and (eq var (binding-var binding))
                                                    (consp (binding-val binding))
                                                    (equal val-class (car (binding-val binding)))))
                                           abox))
                              aboxes)))
          ;(format t "~%relatives=~S" relatives)
          (unless
              (every #'(lambda (C)
                         (some #'(lambda (relative)
                                   ;(format t "~%C=~S~%Relative=~S" C relative)
                                   (isthere var `(,C) relative))
                                relatives))
                     (args val-class))
            ;; branch and collect
            (return-from %union-transform
              (transform (mapcar #'(lambda (C)
                                     (cond ((isthere var `(,C) abox) abox)
                                           (t (insert-bindings var `(instance ,C) abox))))
                           (args val-class)))))))
       ((Intersect Exists Forall Fills Not <= >= =) )
       (otherwise
        (error "Not Yet!")
        ))))
  (cl:list abox))


#|
(trace intersect-transform union-transform clash-p abox-disjoint-p tbox-disjoint-p disjoint-p %owl-disjoint-p)
Satisfiability-check for OWL class
;; Atomic
(satisfied-p '(()) 'vin:Region)
(satisfied-p '(()) vin:Region)
(satisfied-p '(()) '(Not vin:Region))
(satisfied-p '(()) '(Intersect vin:Region (Not vin:Region)))
(satisfied-p '(()) `(Intersect ,vin:Region (Not ,vin:Region)))
;; Complements
(satisfied-p '(()) `(Intersect ,food:ConsumableThing ,food:NonConsumableThing))
(satisfied-p '(()) '(Intersect food:ConsumableThing food:NonConsumableThing))
;; Disjoints
(satisfied-p '(()) '(Intersect vin:LateHarvest vin:EarlyHarvest))
;; Intersects
(satisfied-p '(()) 'vin:Zinfandel)
(satisfied-p '(()) 'vin:RedWine)
(satisfied-p '(()) '(Intersect vin:Wine vin:RedWine))
(satisfied-p '(()) `(Intersect ,vin:WhiteWine ,vin:RedWine))
(satisfied-p '(()) `(Intersect ,vin:WineBody ,vin:WineSugar))
(satisfied-p '(()) `(Intersect ,vin:WineTaste ,vin:WineSugar))
(satisfied-p '(()) `(Intersect ,vin:WineTaste ,vin:WineColor))
;;|owl|:|unionOf|
(satisfied-p '(()) vin:WineDescriptor)
(satisfied-p '(()) `(Intersect ,vin:WineDescriptor ,vin:WineTaste))
(satisfied-p '(()) `(Intersect ,vin:WineDescriptor ,vin:WineBody))

(satisfied-p '(()) `(Intersect ,|owl|:|Thing| ,|owl|:|Nothing|))

(satisfied-p '(()) `(Intersect ,vin:RedWine (Not ,vin:Wine)))
|#

(defun unsatisfied-p (aboxes P)
  "P is a sentence, normally a complex concept.
   This function returns clash models with P."
  ; Conjunction Normal Form (CNF) is also NNF
  (setq aboxes
        (transform (loop for abox in aboxes
                       collect (extend-bindings (new-variable "x") (cl:list (=>cnf P)) abox))))
  (loop for abox in aboxes with result
      do (setq result (clash-p abox))
        (when (null result) ; exists a model
          (return-from unsatisfied-p cl:nil))
      append result))

#|
(unsatisfied-p '(()) `(Intersect ,vin:WhiteWine ,vin:RedWine))
(unsatisfied-p '(()) `(Intersect ,vin:WineBody ,vin:WineSugar))
(unsatisfied-p '(()) `(Intersect ,vin:WineTaste ,vin:WineSugar))
|#

;; x:(Exists R C) = (x . ((Exists R C))) -> (z . (instance C)), (x . (related z R))
(defun exists-transform (abox)
  "returns transformed abox."
  (loop for (var . val) in abox
      do (cond ((%instance-p val)
                (setq abox (%exists-transform var (class-of val) abox)))
               ((and (symbolp val) (boundp val) (%instance-p (symbol-value val)))
                (setq abox (%exists-transform var (class-of (symbol-value val)) abox)))
               ((consp val)
                (cond ((%predicate?+ (op val)) (error "Illegal value, debug!"))
                      ((%concept?+ (op val))
                       (setq abox (%exists-transform var (op val) abox)))
                      ((error "Cant happen!"))))
               ((error "Cant happen!"))))
  abox)

;; val-class = (Exists R C)
(defun %exists-transform (var val-class abox)
  ;; returns transformed abox
  (etypecase val-class
    (symbol
     (when (cl:typep (symbol-value val-class) |owl|:|someValuesFromRestriction|)
       (let ((newval `((Exists ,(name (slot-value (symbol-value val-class) '|owl|:|onProperty|))
                               ,(slot-value (symbol-value val-class) '|owl|:|someValuesFrom|)))))
         (unless (isthere var newval abox)
           (return-from %exists-transform
             (exists-transform (insert-bindings var newval abox)))))))
    (|owl|:|someValuesFromRestriction|
     (when (slot-value val-class '|owl|:|someValuesFrom|)
       (let ((newval `((Exists ,(name (slot-value val-class '|owl|:|onProperty|))
                               ,(slot-value val-class '|owl|:|someValuesFrom|)))))
         (unless (isthere var newval abox)
           (return-from %exists-transform
             (exists-transform (insert-bindings var newval abox)))))))
    (cons
     (case (op val-class)
       (Exists ; (x . ((Exists R C))) -> z:C, x:(R z)
        (let ((R (arg1 val-class))
              (C (arg2 val-class))
              (z ()))
          (cond ((slot-value+ var R abox)) ; nothing done
                (t (setq abox (insert-bindings var `((,R ,(setq z (new-variable "z")))) abox))))
          (unless (owl-equivalent-p (class-of+ z abox) C)
            (setq abox (append-bindings- z C abox)))))
       ((Intersect UnionOf Exists Forall Fills Not <= >= =) )
       (otherwise
        (error "Not Yet!")
        ))))
  abox)

#|
(satisfied-p '((?x . ((Exists vin:locatedIn vin:Region)))) cl:nil))
|#

;; (|owl|:|Class| C)               C is an instance of |owl|:|Class| in SWCLOS
;; (|rdf|:|Property| R)            R is an instance of |rdf|:|Property| in SWCLOS

;; In ABox
;; (C a)               a is in C
;; (R a b)             a R b . in triple

;; +top+
;; +bottom+
;; (Intersect C D)      <=> (Not (UnionOf (Not C) (Not D)))
;; (UnionOf C D)          <=> (Not (Intersect (Not C) (Not D)))
;; (Forall R)           <=> (Not (Exists R +bottom+))
;; (Forall R A)         <=> (Not (Exists R (Not A)))
;; (Exists R)           <=> (Not (Forall R +bottom+))
;; (Exists R A)         <=> (Not (Forall R (Not A)))
;; (Fills R a)          <=> (Exists R (Oneof a))
;; (Fills R a b c)      <=> (Exists R (Oneof a b c))
;; (>= 1 R)             <=> (Not (<= 0 R))
;; (<= 3 R)             <=> (Not (>= 4 R))
;; (= 1 R)              <=> (>= 1 R), (<= 1 R) <=> (Not (<= 2 R)), (Not (>= 2 R))
;; (Not C)
;; (Sub C D)            <=> (Sub (Intersect C (Not D)) +bottom+)
;; (Equ C D)            <=> (Sub C D) and (Sub D C)
;;                      <=> (Sub (Intersect C (Not D)) +bottom+) and (Sub (Intersect D (Not C)) +bottom+)
;; (Oneof a b c)
;; (Disjoint C D)       <=> (Sub (Intersect C D) +bottom+)
;;
;;   (Sub Woman Person)
;;   (Equ Mother (Intersect Woman (Exists hasChild Person))
;;   (Equ Parent (UnionOf Mother Father))
;;
;;   (Forall (R S) A) or (Forall R (Forall S A)
;;   (Forall R (Exists S A))

;;
;;
;;

;;
;; Following codes are modified from AIMA to SWCLS so as to accept CLOS objects as DL expression.

(defun MoveNotInwards (p)
  "Given P, return ~P, but with the negation moved as far in as possible."
  (case (op p)
    ((t) '+bottom+)           ; seiji
    ((cl:nil) '+top+)         ; seiji
    (+top+ +bottom+)          ; seiji
    (+bottom+ +top+)          ; seiji
    (Not (arg1 p))
    (Intersect (UnionOf (mapcar #'MoveNotInwards (args p))))
    (UnionOf   (Intersect (mapcar #'MoveNotInwards (args p))))
    (Forall (make-exp 'Exists (arg1 p) (MoveNotInwards (or (arg2 p) +top+))))
    (Exists (make-exp 'Forall (arg1 p) (MoveNotInwards (or (arg2 p) +top+))))
    (<= `(>= ,(1+ (arg1 p)) ,(arg2 p)))
    (>= `(<= ,(1- (arg1 p)) ,(arg2 p)))
    (= `(and (>= ,(1+ (arg1 p)) ,(arg2 p)) (<= ,(1- (arg1 p)) ,(arg2 p))))
    (t (make-exp 'Not p))))

(defun =>cnf (p &optional vars)
  "Convert a sentence p to conjunctive normal form [p 279-280]."
  ;; That is, return (Intersect (UnionOf ...) ...) where
  ;; each of the conjuncts has all literal disjuncts.
  ;; VARS is a list of universally quantified variables that P is in scope of.
  (setf p (eliminate-implications (logic p)))
  (case (op p)
    (not (let ((p2 (move-not-inwards (arg1 p))))
           (if (literal-clause? p2) p2 (=>cnf p2 vars))))
    (Not (let ((p2 (MoveNotInwards (arg1 p))))
           (if (literal-clause? p2) p2 (=>cnf p2 vars))))
    (and (conjunction (mappend #'(lambda (q) (conjuncts (=>cnf q vars))) (args p))))
    (Intersect (Conjunction (mappend #'(lambda (q) (conjuncts (=>cnf q vars))) (args p))))
    (or  (merge-disjuncts (mapcar #'(lambda (q) (=>cnf q vars)) (args p))))
    (UnionOf  (MergeDisjuncts (mapcar #'(lambda (q) (=>cnf q vars)) (args p))))
    (forall (let ((new-vars (mapcar #'new-variable  (mklist (arg1 p)))))
              (=>cnf (sublis (mapcar #'cons  (mklist (arg1 p)) new-vars)
                             (arg2 p))
                     (append new-vars vars))))
    (Forall (let ((new-vars (mapcar #'new-variable  (mklist (arg1 p)))))
              (=>cnf (sublis (mapcar #'cons  (mklist (arg1 p)) new-vars)
                             (arg2 p))
                     (append new-vars vars))))
    (exists (=>cnf (skolemize (arg2 p) (arg1 p) vars) vars))
    (Exists (=>cnf (skolemize (arg2 p) (arg1 p) vars) vars))
    (t   p) ; p is atomic
    ))

(defun UnionOf (args)
  "Form a disjunction with these args."
  (case (length args)
    (0 '+bottom+)              ; seiji
    (1 (cl:first args))
    (t (cons 'UnionOf args))))

(defun Intersect (args)
  "Form a conjunction with these args."
  (case (length args)
    (0 '+top+)                   ; seiji
    (1 (cl:first args))
    (t (cons 'Intersect args))))

#|
(=>cnf '(Not (UnionOf (Not C) (Not D))))    -> (Intersect C D)
(=>cnf '(Not (Intersect (Not C) (Not D))) -> (UnionOf C D)
(=>cnf '(Not (Exists R +bottom+)))        -> (Forall R +top+)
(=>cnf '(Not (Forall R +bottom+)))        -> (Exists R +top+)
(=>cnf '(Not (Exists R)))                 -> (Forall R +bottom+)
(=>cnf '(Not (Forall R)))                 -> (Exists R +bottom+)
(=>cnf '(Not (<= 0 R)))                   -> (>= 1 R)
(=>cnf '(Not (>= 4 R)))                   -> (<= 3 R)
(=>cnf '(Not (= 3 R)))                    -> (and (>= 4 R) (<= 2 R))
|#

(provide :tableau)
